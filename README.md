# Speller


This project is a C-based spell-checker that loads a dictionary file into memory, checks spelling for text files against it, and reports any misspellings. It utilizes <b>hash tables</b> and linked lists for efficient storage and lookup, designed to handle even large dictionaries of over 140,000 words. The program features several key functions that load, check, hash, and manage dictionary words, ensuring high performance in terms of time and memory efficiency.


## Files


The main components of this project are three files: `dictionary.h`, `dictionary.c`, and `speller.c`. Each plays a critical role in setting up the spell checker.


### 1. dictionary.h
This header file defines constants, structures, and prototypes for functions used across the program.
- **Function Prototypes**:
  - `bool check(const char *word);`
  - `unsigned int hash(const char *word);`
  - `bool load(const char *dictionary);`
  - `unsigned int size(void);`
  - `bool unload(void);`


  These functions enable word checking, hashing, dictionary loading, retrieving the dictionary size, and unloading dictionary data from memory.


### 2. dictionary.c
This file contains implementations of the core functions for the spell-checker. Here’s a breakdown:
- **Functions**:
  - **load**: Reads words from the dictionary file and stores them in the hash table, allocating memory dynamically for each `node`.
  - **check**: Looks up each word in the hash table to confirm if it exists in the dictionary.
  - **size**: Returns the total number of words in the loaded dictionary.
  - **unload**: Frees up all memory allocated for dictionary storage, ensuring no memory leaks.


### 3. speller.c
`speller.c` is the main driver for the spell-checker program. It reads the dictionary and text file inputs, checks each word against the dictionary, and reports misspellings.


## Key Functions and Hashing


1. **Hashing**:
   - The `hash` function generates an index for each word based on its first letters, using a formula that maps words to an integer value, which points to a bucket in the hash table. For larger dictionaries, the hash function can be adapted to use more characters or different algorithms for more even distribution.


2. **Linked Lists**:
   - Each hash table bucket contains a linked list of `node`s to handle collisions, storing multiple words that hash to the same index. This structure enables efficient traversal and insertion for dictionaries of all sizes.


3. **Spell-Checking**:
   - Each word in the text file is checked against the dictionary. If the word does not exist in the hash table, it’s marked as a misspelling. This approach allows for fast, case-insensitive spell-checking.

To include the output results in the report, you can add a **Results** section that describes the outcome of the spell-checker. Here’s an example of how you might incorporate this information into the report:


## Results

Below is a sample output generated by the spell-checker program. This output includes a list of words identified as misspelled and performance metrics for each function.


<img width="600" alt="image" src="https://github.com/user-attachments/assets/6d5cae0e-523b-4f5b-9135-40c1312f89eb">



### Explanation of Output

- **Statistics**:
  - **WORDS MISSPELLED**: The total count of misspelled words detected in the text file.
  - **WORDS IN DICTIONARY**: The number of words loaded from the dictionary file, in this case, 143,091.
  - **WORDS IN TEXT**: The total number of words checked in the text file, here, 7,573.
  - **Execution Times**:
    - **TIME IN load**: The time taken to load the dictionary into memory.
    - **TIME IN check**: The cumulative time to check each word in the text file.
    - **TIME IN size**: The time taken to calculate the size of the dictionary.
    - **TIME IN unload**: The time required to free memory and unload the dictionary.
    - **TIME IN TOTAL**: The overall time taken for the entire process.

### Performance Summary

The program demonstrates efficient handling of large dictionaries and text files. With the dictionary loading in just 0.02 seconds and the checking process taking only 0.01 seconds, it shows optimal usage of hash tables and linked lists. This fast execution time highlights the efficiency of the data structures used, making it scalable for larger texts and dictionaries.


## How to Use

1. Compile the program with `make speller`.
2. Run `./speller texts/constitution.txt`

---


